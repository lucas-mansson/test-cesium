var Ii = Object.defineProperty;
var Wi = (i, e, t) => e in i ? Ii(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t;
var K = (i, e, t) => (Wi(i, typeof e != "symbol" ? e + "" : e, t), t);
import di, { createContext as Vi, useContext as Ui, useRef as I, useEffect as le, useState as mi, useCallback as we, useLayoutEffect as ji, useImperativeHandle as Hi, forwardRef as fi, useMemo as zi } from "react";
import { ScreenSpaceEventType as $, ScreenSpaceEventHandler as hi, Event as ei, BillboardCollection as xi, BillboardGraphics as Ni, BoxGraphics as qi, Cesium3DTileset as Yi, Cesium3DTilesetGraphics as Ki, CesiumWidget as Ji, ClassificationPrimitive as Zi, CloudCollection as Xi, CorridorGraphics as Qi, CustomDataSource as et, CylinderGraphics as it, CzmlDataSource as tt, EllipseGraphics as nt, EllipsoidGraphics as ot, Entity as rt, Fog as ii, GeoJsonDataSource as st, GroundPolylinePrimitive as at, GroundPrimitive as ct, ImageryLayer as lt, KmlDataSource as ut, LabelCollection as dt, LabelGraphics as mt, Model as ft, ModelGraphics as ht, Moon as ti, ParticleSystem as yt, PathGraphics as pt, PlaneGraphics as vt, PointGraphics as gt, PointPrimitiveCollection as Ct, PolygonGraphics as Pt, PolylineCollection as St, PolylineGraphics as Et, PolylineVolumeGraphics as bt, PostProcessStage as wt, PostProcessStageLibrary as Z, PostProcessStageComposite as Dt, Primitive as Rt, RectangleGraphics as $t, SceneMode as Be, Sun as ni, TimeDynamicPointCloud as Tt, Viewer as Mt, WallGraphics as kt } from "cesium";
import { createPortal as Lt } from "react-dom";
const We = Vi({}), { Provider: hs, Consumer: _t } = We, $e = () => Ui(We) || {}, Te = (i, e) => {
  const t = (o) => {
    const r = $e(), c = I(), u = I(!1);
    return le(() => () => {
      r.camera && o.cancelFlightOnUnmount && r.camera.cancelFlight();
    }, [r.camera, o.cancelFlightOnUnmount]), le(() => {
      r.camera && r.scene && !r.scene.isDestroyed() && (!o.once || !u.current) && (r.camera.cancelFlight(), e(r.camera, o, c.current), u.current = !0), c.current = o;
    }), null;
  };
  return t.displayName = i, t;
};
var Ae = { exports: {} }, ye = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var oi;
function Ot() {
  if (oi)
    return ye;
  oi = 1;
  var i = di, e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), o = Object.prototype.hasOwnProperty, r = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, c = { key: !0, ref: !0, __self: !0, __source: !0 };
  function u(h, d, C) {
    var y, T = {}, M = null, v = null;
    C !== void 0 && (M = "" + C), d.key !== void 0 && (M = "" + d.key), d.ref !== void 0 && (v = d.ref);
    for (y in d)
      o.call(d, y) && !c.hasOwnProperty(y) && (T[y] = d[y]);
    if (h && h.defaultProps)
      for (y in d = h.defaultProps, d)
        T[y] === void 0 && (T[y] = d[y]);
    return { $$typeof: e, type: h, key: M, ref: v, props: T, _owner: r.current };
  }
  return ye.Fragment = t, ye.jsx = u, ye.jsxs = u, ye;
}
var pe = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ri;
function Gt() {
  return ri || (ri = 1, process.env.NODE_ENV !== "production" && function() {
    var i = di, e = Symbol.for("react.element"), t = Symbol.for("react.portal"), o = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), c = Symbol.for("react.profiler"), u = Symbol.for("react.provider"), h = Symbol.for("react.context"), d = Symbol.for("react.forward_ref"), C = Symbol.for("react.suspense"), y = Symbol.for("react.suspense_list"), T = Symbol.for("react.memo"), M = Symbol.for("react.lazy"), v = Symbol.for("react.offscreen"), k = Symbol.iterator, N = "@@iterator";
    function X(n) {
      if (n === null || typeof n != "object")
        return null;
      var s = k && n[k] || n[N];
      return typeof s == "function" ? s : null;
    }
    var _ = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function E(n) {
      {
        for (var s = arguments.length, a = new Array(s > 1 ? s - 1 : 0), m = 1; m < s; m++)
          a[m - 1] = arguments[m];
        Q("error", n, a);
      }
    }
    function Q(n, s, a) {
      {
        var m = _.ReactDebugCurrentFrame, g = m.getStackAddendum();
        g !== "" && (s += "%s", a = a.concat([g]));
        var P = a.map(function(p) {
          return String(p);
        });
        P.unshift("Warning: " + s), Function.prototype.apply.call(console[n], console, P);
      }
    }
    var ge = !1, ne = !1, ue = !1, oe = !1, de = !1, j;
    j = Symbol.for("react.module.reference");
    function ee(n) {
      return !!(typeof n == "string" || typeof n == "function" || n === o || n === c || de || n === r || n === C || n === y || oe || n === v || ge || ne || ue || typeof n == "object" && n !== null && (n.$$typeof === M || n.$$typeof === T || n.$$typeof === u || n.$$typeof === h || n.$$typeof === d || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      n.$$typeof === j || n.getModuleId !== void 0));
    }
    function me(n, s, a) {
      var m = n.displayName;
      if (m)
        return m;
      var g = s.displayName || s.name || "";
      return g !== "" ? a + "(" + g + ")" : a;
    }
    function re(n) {
      return n.displayName || "Context";
    }
    function A(n) {
      if (n == null)
        return null;
      if (typeof n.tag == "number" && E("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof n == "function")
        return n.displayName || n.name || null;
      if (typeof n == "string")
        return n;
      switch (n) {
        case o:
          return "Fragment";
        case t:
          return "Portal";
        case c:
          return "Profiler";
        case r:
          return "StrictMode";
        case C:
          return "Suspense";
        case y:
          return "SuspenseList";
      }
      if (typeof n == "object")
        switch (n.$$typeof) {
          case h:
            var s = n;
            return re(s) + ".Consumer";
          case u:
            var a = n;
            return re(a._context) + ".Provider";
          case d:
            return me(n, n.render, "ForwardRef");
          case T:
            var m = n.displayName || null;
            return m !== null ? m : A(n.type) || "Memo";
          case M: {
            var g = n, P = g._payload, p = g._init;
            try {
              return A(p(P));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var W = Object.assign, b = 0, D, L, B, V, O, q, Y;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function fe() {
      {
        if (b === 0) {
          D = console.log, L = console.info, B = console.warn, V = console.error, O = console.group, q = console.groupCollapsed, Y = console.groupEnd;
          var n = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: n,
            log: n,
            warn: n,
            error: n,
            group: n,
            groupCollapsed: n,
            groupEnd: n
          });
        }
        b++;
      }
    }
    function ie() {
      {
        if (b--, b === 0) {
          var n = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: W({}, n, {
              value: D
            }),
            info: W({}, n, {
              value: L
            }),
            warn: W({}, n, {
              value: B
            }),
            error: W({}, n, {
              value: V
            }),
            group: W({}, n, {
              value: O
            }),
            groupCollapsed: W({}, n, {
              value: q
            }),
            groupEnd: W({}, n, {
              value: Y
            })
          });
        }
        b < 0 && E("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var te = _.ReactCurrentDispatcher, z;
    function Ce(n, s, a) {
      {
        if (z === void 0)
          try {
            throw Error();
          } catch (g) {
            var m = g.stack.trim().match(/\n( *(at )?)/);
            z = m && m[1] || "";
          }
        return `
` + z + n;
      }
    }
    var Me = !1, Pe;
    {
      var yi = typeof WeakMap == "function" ? WeakMap : Map;
      Pe = new yi();
    }
    function Ve(n, s) {
      if (!n || Me)
        return "";
      {
        var a = Pe.get(n);
        if (a !== void 0)
          return a;
      }
      var m;
      Me = !0;
      var g = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var P;
      P = te.current, te.current = null, fe();
      try {
        if (s) {
          var p = function() {
            throw Error();
          };
          if (Object.defineProperty(p.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(p, []);
            } catch (x) {
              m = x;
            }
            Reflect.construct(n, [], p);
          } else {
            try {
              p.call();
            } catch (x) {
              m = x;
            }
            n.call(p.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (x) {
            m = x;
          }
          n();
        }
      } catch (x) {
        if (x && m && typeof x.stack == "string") {
          for (var f = x.stack.split(`
`), G = m.stack.split(`
`), w = f.length - 1, R = G.length - 1; w >= 1 && R >= 0 && f[w] !== G[R]; )
            R--;
          for (; w >= 1 && R >= 0; w--, R--)
            if (f[w] !== G[R]) {
              if (w !== 1 || R !== 1)
                do
                  if (w--, R--, R < 0 || f[w] !== G[R]) {
                    var F = `
` + f[w].replace(" at new ", " at ");
                    return n.displayName && F.includes("<anonymous>") && (F = F.replace("<anonymous>", n.displayName)), typeof n == "function" && Pe.set(n, F), F;
                  }
                while (w >= 1 && R >= 0);
              break;
            }
        }
      } finally {
        Me = !1, te.current = P, ie(), Error.prepareStackTrace = g;
      }
      var ae = n ? n.displayName || n.name : "", Qe = ae ? Ce(ae) : "";
      return typeof n == "function" && Pe.set(n, Qe), Qe;
    }
    function pi(n, s, a) {
      return Ve(n, !1);
    }
    function vi(n) {
      var s = n.prototype;
      return !!(s && s.isReactComponent);
    }
    function Se(n, s, a) {
      if (n == null)
        return "";
      if (typeof n == "function")
        return Ve(n, vi(n));
      if (typeof n == "string")
        return Ce(n);
      switch (n) {
        case C:
          return Ce("Suspense");
        case y:
          return Ce("SuspenseList");
      }
      if (typeof n == "object")
        switch (n.$$typeof) {
          case d:
            return pi(n.render);
          case T:
            return Se(n.type, s, a);
          case M: {
            var m = n, g = m._payload, P = m._init;
            try {
              return Se(P(g), s, a);
            } catch {
            }
          }
        }
      return "";
    }
    var Ee = Object.prototype.hasOwnProperty, Ue = {}, je = _.ReactDebugCurrentFrame;
    function be(n) {
      if (n) {
        var s = n._owner, a = Se(n.type, n._source, s ? s.type : null);
        je.setExtraStackFrame(a);
      } else
        je.setExtraStackFrame(null);
    }
    function gi(n, s, a, m, g) {
      {
        var P = Function.call.bind(Ee);
        for (var p in n)
          if (P(n, p)) {
            var f = void 0;
            try {
              if (typeof n[p] != "function") {
                var G = Error((m || "React class") + ": " + a + " type `" + p + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof n[p] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw G.name = "Invariant Violation", G;
              }
              f = n[p](s, p, m, a, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (w) {
              f = w;
            }
            f && !(f instanceof Error) && (be(g), E("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", m || "React class", a, p, typeof f), be(null)), f instanceof Error && !(f.message in Ue) && (Ue[f.message] = !0, be(g), E("Failed %s type: %s", a, f.message), be(null));
          }
      }
    }
    var Ci = Array.isArray;
    function ke(n) {
      return Ci(n);
    }
    function Pi(n) {
      {
        var s = typeof Symbol == "function" && Symbol.toStringTag, a = s && n[Symbol.toStringTag] || n.constructor.name || "Object";
        return a;
      }
    }
    function Si(n) {
      try {
        return He(n), !1;
      } catch {
        return !0;
      }
    }
    function He(n) {
      return "" + n;
    }
    function ze(n) {
      if (Si(n))
        return E("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Pi(n)), He(n);
    }
    var he = _.ReactCurrentOwner, Ei = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, xe, Ne, Le;
    Le = {};
    function bi(n) {
      if (Ee.call(n, "ref")) {
        var s = Object.getOwnPropertyDescriptor(n, "ref").get;
        if (s && s.isReactWarning)
          return !1;
      }
      return n.ref !== void 0;
    }
    function wi(n) {
      if (Ee.call(n, "key")) {
        var s = Object.getOwnPropertyDescriptor(n, "key").get;
        if (s && s.isReactWarning)
          return !1;
      }
      return n.key !== void 0;
    }
    function Di(n, s) {
      if (typeof n.ref == "string" && he.current && s && he.current.stateNode !== s) {
        var a = A(he.current.type);
        Le[a] || (E('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', A(he.current.type), n.ref), Le[a] = !0);
      }
    }
    function Ri(n, s) {
      {
        var a = function() {
          xe || (xe = !0, E("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", s));
        };
        a.isReactWarning = !0, Object.defineProperty(n, "key", {
          get: a,
          configurable: !0
        });
      }
    }
    function $i(n, s) {
      {
        var a = function() {
          Ne || (Ne = !0, E("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", s));
        };
        a.isReactWarning = !0, Object.defineProperty(n, "ref", {
          get: a,
          configurable: !0
        });
      }
    }
    var Ti = function(n, s, a, m, g, P, p) {
      var f = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: n,
        key: s,
        ref: a,
        props: p,
        // Record the component responsible for creating this element.
        _owner: P
      };
      return f._store = {}, Object.defineProperty(f._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(f, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: m
      }), Object.defineProperty(f, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: g
      }), Object.freeze && (Object.freeze(f.props), Object.freeze(f)), f;
    };
    function Mi(n, s, a, m, g) {
      {
        var P, p = {}, f = null, G = null;
        a !== void 0 && (ze(a), f = "" + a), wi(s) && (ze(s.key), f = "" + s.key), bi(s) && (G = s.ref, Di(s, g));
        for (P in s)
          Ee.call(s, P) && !Ei.hasOwnProperty(P) && (p[P] = s[P]);
        if (n && n.defaultProps) {
          var w = n.defaultProps;
          for (P in w)
            p[P] === void 0 && (p[P] = w[P]);
        }
        if (f || G) {
          var R = typeof n == "function" ? n.displayName || n.name || "Unknown" : n;
          f && Ri(p, R), G && $i(p, R);
        }
        return Ti(n, f, G, g, m, he.current, p);
      }
    }
    var _e = _.ReactCurrentOwner, qe = _.ReactDebugCurrentFrame;
    function se(n) {
      if (n) {
        var s = n._owner, a = Se(n.type, n._source, s ? s.type : null);
        qe.setExtraStackFrame(a);
      } else
        qe.setExtraStackFrame(null);
    }
    var Oe;
    Oe = !1;
    function Ge(n) {
      return typeof n == "object" && n !== null && n.$$typeof === e;
    }
    function Ye() {
      {
        if (_e.current) {
          var n = A(_e.current.type);
          if (n)
            return `

Check the render method of \`` + n + "`.";
        }
        return "";
      }
    }
    function ki(n) {
      {
        if (n !== void 0) {
          var s = n.fileName.replace(/^.*[\\\/]/, ""), a = n.lineNumber;
          return `

Check your code at ` + s + ":" + a + ".";
        }
        return "";
      }
    }
    var Ke = {};
    function Li(n) {
      {
        var s = Ye();
        if (!s) {
          var a = typeof n == "string" ? n : n.displayName || n.name;
          a && (s = `

Check the top-level render call using <` + a + ">.");
        }
        return s;
      }
    }
    function Je(n, s) {
      {
        if (!n._store || n._store.validated || n.key != null)
          return;
        n._store.validated = !0;
        var a = Li(s);
        if (Ke[a])
          return;
        Ke[a] = !0;
        var m = "";
        n && n._owner && n._owner !== _e.current && (m = " It was passed a child from " + A(n._owner.type) + "."), se(n), E('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', a, m), se(null);
      }
    }
    function Ze(n, s) {
      {
        if (typeof n != "object")
          return;
        if (ke(n))
          for (var a = 0; a < n.length; a++) {
            var m = n[a];
            Ge(m) && Je(m, s);
          }
        else if (Ge(n))
          n._store && (n._store.validated = !0);
        else if (n) {
          var g = X(n);
          if (typeof g == "function" && g !== n.entries)
            for (var P = g.call(n), p; !(p = P.next()).done; )
              Ge(p.value) && Je(p.value, s);
        }
      }
    }
    function _i(n) {
      {
        var s = n.type;
        if (s == null || typeof s == "string")
          return;
        var a;
        if (typeof s == "function")
          a = s.propTypes;
        else if (typeof s == "object" && (s.$$typeof === d || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        s.$$typeof === T))
          a = s.propTypes;
        else
          return;
        if (a) {
          var m = A(s);
          gi(a, n.props, "prop", m, n);
        } else if (s.PropTypes !== void 0 && !Oe) {
          Oe = !0;
          var g = A(s);
          E("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", g || "Unknown");
        }
        typeof s.getDefaultProps == "function" && !s.getDefaultProps.isReactClassApproved && E("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Oi(n) {
      {
        for (var s = Object.keys(n.props), a = 0; a < s.length; a++) {
          var m = s[a];
          if (m !== "children" && m !== "key") {
            se(n), E("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", m), se(null);
            break;
          }
        }
        n.ref !== null && (se(n), E("Invalid attribute `ref` supplied to `React.Fragment`."), se(null));
      }
    }
    function Xe(n, s, a, m, g, P) {
      {
        var p = ee(n);
        if (!p) {
          var f = "";
          (n === void 0 || typeof n == "object" && n !== null && Object.keys(n).length === 0) && (f += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var G = ki(g);
          G ? f += G : f += Ye();
          var w;
          n === null ? w = "null" : ke(n) ? w = "array" : n !== void 0 && n.$$typeof === e ? (w = "<" + (A(n.type) || "Unknown") + " />", f = " Did you accidentally export a JSX literal instead of a component?") : w = typeof n, E("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", w, f);
        }
        var R = Mi(n, s, a, g, P);
        if (R == null)
          return R;
        if (p) {
          var F = s.children;
          if (F !== void 0)
            if (m)
              if (ke(F)) {
                for (var ae = 0; ae < F.length; ae++)
                  Ze(F[ae], n);
                Object.freeze && Object.freeze(F);
              } else
                E("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Ze(F, n);
        }
        return n === o ? Oi(R) : _i(R), R;
      }
    }
    function Gi(n, s, a) {
      return Xe(n, s, a, !0);
    }
    function Bi(n, s, a) {
      return Xe(n, s, a, !1);
    }
    var Ai = Bi, Fi = Gi;
    pe.Fragment = o, pe.jsx = Ai, pe.jsxs = Fi;
  }()), pe;
}
process.env.NODE_ENV === "production" ? Ae.exports = Ot() : Ae.exports = Gt();
var H = Ae.exports;
function Bt(i, e) {
  return e ? Fe(i).reduce(
    (t, [o, r]) => (ve(e, o) && (t[o] = r), t),
    {}
  ) : {};
}
function Fe(i) {
  return Object.keys(i).map((e) => [e, i[e]]);
}
function ve(i, e) {
  return !!i && i.indexOf(e) !== -1;
}
function At(i, e) {
  return !!i && !!e && [...Object.keys(i), ...Object.keys(e)].every((t) => i[t] === e[t]);
}
function Ft(i) {
  return i && typeof i.isDestroyed == "function" && typeof i.destroy == "function";
}
function It(i) {
  return Ft(i) && i.isDestroyed();
}
function J(i) {
  return i && typeof i == "object" && "then" in i && typeof i.then == "function";
}
const ce = "__RESIUM_EVENT_MANAGER", Ie = [
  "onClick",
  "onDoubleClick",
  "onMouseDown",
  "onMouseUp",
  "onMiddleClick",
  "onMiddleDown",
  "onMiddleUp",
  "onMouseMove",
  "onPinchEnd",
  "onPinchMove",
  "onPinchStart",
  "onRightClick",
  "onRightDown",
  "onRightUp",
  "onWheel",
  "onMouseEnter",
  "onMouseLeave"
], Re = class Re {
  constructor(e) {
    K(this, "scene");
    K(this, "sshe");
    K(this, "events", {
      onClick: /* @__PURE__ */ new Map(),
      onDoubleClick: /* @__PURE__ */ new Map(),
      onMouseDown: /* @__PURE__ */ new Map(),
      onMouseUp: /* @__PURE__ */ new Map(),
      onMiddleClick: /* @__PURE__ */ new Map(),
      onMiddleDown: /* @__PURE__ */ new Map(),
      onMiddleUp: /* @__PURE__ */ new Map(),
      onMouseMove: /* @__PURE__ */ new Map(),
      onPinchEnd: /* @__PURE__ */ new Map(),
      onPinchMove: /* @__PURE__ */ new Map(),
      onPinchStart: /* @__PURE__ */ new Map(),
      onRightClick: /* @__PURE__ */ new Map(),
      onRightDown: /* @__PURE__ */ new Map(),
      onRightUp: /* @__PURE__ */ new Map(),
      onWheel: /* @__PURE__ */ new Map(),
      onMouseEnter: /* @__PURE__ */ new Map(),
      onMouseLeave: /* @__PURE__ */ new Map()
    });
    K(this, "hovered");
    K(this, "onMouseMove", (e) => {
      var o, r, c, u, h, d;
      const t = this.pick(e.endPosition);
      this.hovered !== t && (this.hovered && ((o = this.getEventCallback("onMouseLeave", this.hovered)) == null || o(e, this.hovered), (r = this.getEventCallback("onMouseLeave", null)) == null || r(e, this.hovered)), t && ((c = this.getEventCallback("onMouseEnter", t)) == null || c(e, t), (u = this.getEventCallback("onMouseEnter", null)) == null || u(e, t))), t && ((h = this.getEventCallback("onMouseMove", t)) == null || h(e, t)), (d = this.getEventCallback("onMouseMove", null)) == null || d(e, t), this.hovered = t;
    });
    K(this, "eventCallback", (e) => (t) => {
      var r, c;
      const o = this.pick(t == null ? void 0 : t.position);
      o && ((r = this.getEventCallback(e, o)) == null || r(t, o)), (c = this.getEventCallback(e, null)) == null || c(t, o);
    });
    this.scene = e, this.sshe = new hi(e == null ? void 0 : e.canvas);
  }
  destroy() {
    this.hovered = void 0, this.sshe.isDestroyed() || this.sshe.destroy();
  }
  isDestroyed() {
    return this.sshe.isDestroyed();
  }
  on(e, t, o) {
    e && t === "onWheel" || this.events[t].set(e, o);
  }
  off(e, t) {
    this.events[t].delete(e), this.hovered === e && (this.hovered = void 0);
  }
  setEvents(e, t) {
    Fe(t).forEach(([o, r]) => {
      const c = o;
      ve(Ie, c) && (r ? this.on(e, c, r) : this.off(e, c));
    }), this.commit();
  }
  clearEvents(e) {
    this.hovered = void 0, Ie.forEach((t) => {
      this.off(e, t);
    }), this.commit();
  }
  commit() {
    const e = this.sshe, t = this.sshe.isDestroyed();
    t || (this.events.onMouseEnter.size === 0 && this.events.onMouseLeave.size === 0 && this.events.onMouseMove.size === 0 ? this.sshe.removeInputAction($.MOUSE_MOVE) : this.sshe.getInputAction($.MOUSE_MOVE) || this.sshe.setInputAction(this.onMouseMove, $.MOUSE_MOVE)), Fe(this.events).forEach(([o, r]) => {
      if (o === "onMouseEnter" || o === "onMouseLeave" || o === "onMouseMove")
        return;
      const c = Re.eventTypeMap[o];
      t || (r.size === 0 ? e.removeInputAction(c) : e.getInputAction(c) || e.setInputAction(this.eventCallback(o), c));
    });
  }
  getScreenSpaceEventHandler() {
    return this.sshe;
  }
  getEventCallback(e, t) {
    var o, r;
    return t === null ? this.events[e].get(null) : this.events[e].get(t.id) || // Entity
    this.events[e].get((r = (o = t.id) == null ? void 0 : o.entityCollection) == null ? void 0 : r.owner) || // Entity in DataSource
    this.events[e].get(t.primitive) || // Primitive
    this.events[e].get(t.tileset);
  }
  pick(e) {
    var t;
    if (e)
      return (t = this.scene) == null ? void 0 : t.pick(e);
  }
};
K(Re, "eventTypeMap", {
  onClick: $.LEFT_CLICK,
  onDoubleClick: $.LEFT_DOUBLE_CLICK,
  onMouseDown: $.LEFT_DOWN,
  onMouseUp: $.LEFT_UP,
  onMiddleClick: $.MIDDLE_CLICK,
  onMiddleDown: $.MIDDLE_DOWN,
  onMiddleUp: $.MIDDLE_UP,
  onMouseMove: $.MOUSE_MOVE,
  onPinchEnd: $.PINCH_END,
  onPinchMove: $.PINCH_MOVE,
  onPinchStart: $.PINCH_START,
  onRightClick: $.RIGHT_CLICK,
  onRightDown: $.RIGHT_DOWN,
  onRightUp: $.RIGHT_UP,
  onWheel: $.WHEEL,
  onMouseEnter: $.MOUSE_MOVE,
  onMouseLeave: $.MOUSE_MOVE
});
let De = Re;
const Wt = ({
  name: i,
  create: e,
  destroy: t,
  provide: o,
  update: r,
  cesiumReadonlyProps: c,
  cesiumEventProps: u,
  otherProps: h,
  setCesiumPropsAfterCreate: d,
  useCommonEvent: C,
  useRootEvent: y
}, T, M) => {
  const v = I(), k = $e(), N = I(o ? {} : void 0), X = I({}), _ = I(si(T)), E = I({}), [Q, ge] = mi(!1), ne = I(!1), ue = I(null), oe = I(), de = k == null ? void 0 : k[ce], j = I(), ee = I(), me = we(
    async (b) => {
      var Y;
      if (!v.current)
        return;
      const D = v.current, L = Object.keys(b), B = Object.keys(u || []), V = L.concat(
        Object.keys(E.current).filter((S) => !L.includes(S))
      ).filter((S) => E.current[S] !== b[S]).map((S) => [S, E.current[S], b[S]]), O = [];
      for (const [S, fe, ie] of V)
        if (c != null && c.includes(S))
          O.push(S);
        else if (ve(B, S)) {
          const te = u == null ? void 0 : u[S], z = D[te];
          z instanceof ei && (typeof fe > "u" ? (z.addEventListener(ie), X.current[te] = ie) : typeof ie > "u" ? (z.removeEventListener(fe), delete X.current[te]) : (z.removeEventListener(fe), z.addEventListener(ie)));
        } else
          S !== "children" && !Ie.includes(S) && !(h != null && h.includes(S)) && (D[S] = ie);
      const q = y ? (Y = N.current) == null ? void 0 : Y[ce] : de;
      if (C && q && v.current && q.setEvents(y ? null : v.current, b), r && ne.current) {
        const S = r(v.current, b, E.current, k);
        J(S) && await S;
      }
      E.current = b, _.current = b, ne.current && O.length > 0 && (process.env.NODE_ENV !== "production" && console.warn(
        `Warning: <${i}> is recreated because following read-only props have been updated: ${O.join(
          ", "
        )}`
      ), A(), await W(), j.current = re());
    },
    []
    // eslint-disable-line react-hooks/exhaustive-deps
  ), re = we(async () => {
    var B;
    await new Promise((V) => queueMicrotask(() => V(void 0)));
    const b = e == null ? void 0 : e(k, _.current, ue.current);
    let D;
    if (J(b) ? D = await b : D = b, Array.isArray(D) ? (v.current = D[0], oe.current = D[1]) : v.current = D, d)
      await me(_.current);
    else {
      if (v.current && u) {
        const V = v.current;
        for (const O of Object.keys(_.current)) {
          const q = u[O];
          if (q) {
            const Y = _.current[O], S = V[q];
            Y && S instanceof ei && S.addEventListener(Y);
          }
        }
      }
      E.current = _.current;
    }
    o && v.current && (N.current = {
      ...k,
      ...o(v.current, k, T, oe.current)
    });
    const L = y ? (B = N.current) == null ? void 0 : B[ce] : de;
    C && L && v.current && L.setEvents(y ? null : v.current, _.current), ee.current || ge(!0);
  }, []), A = we(() => {
    ge(!1), ne.current = !1;
  }, []), W = we(async () => {
    var D, L;
    await new Promise((B) => queueMicrotask(() => B(void 0))), j.current && (await j.current, j.current = void 0), v.current && t && t(v.current, k, ue.current, oe.current);
    const b = y ? (D = N.current) == null ? void 0 : D[ce] : de;
    if (C && b && v.current && b.clearEvents(y ? null : v.current), v.current && !It(v.current)) {
      const B = Object.keys(X.current);
      for (const V of B) {
        const O = v.current[V];
        (L = O == null ? void 0 : O.removeEventListener) == null || L.call(O, X.current[V]);
      }
    }
    X.current = {}, N.current = void 0, oe.current = void 0, v.current = void 0;
  }, []);
  return ji(() => ((async () => {
    ee.current && (await ee.current, ee.current = void 0), j.current = re();
  })(), () => {
    A(), ee.current = W();
  }), [re, W, A]), le(() => {
    (async () => {
      var L, B;
      j.current && await j.current;
      const D = si(T);
      Q ? At(D, E.current) || (await me(D), (B = (L = k.__$internal) == null ? void 0 : L.onUpdate) == null || B.call(L)) : (E.current = D, _.current = D, ne.current = !0);
    })();
  }, [k.__$internal, Q, T, me]), Hi(
    M,
    () => ({
      cesiumElement: Q ? v.current : null
    }),
    [Q]
  ), [N.current, Q, ue];
};
function si(i) {
  const { children: e, ...t } = i;
  return t;
}
const l = ({
  renderContainer: i,
  noChildren: e,
  containerProps: t,
  defaultProps: o,
  ...r
}) => {
  const c = (u, h) => {
    const d = {
      ...o,
      ...u
    }, [C, y, T] = Wt(
      r,
      d,
      h
    );
    if (e)
      return null;
    const M = y && "children" in d ? d.children : null, v = i ? /* @__PURE__ */ H.jsx(
      "div",
      {
        "data-testid": "resium-container",
        ref: T,
        ...typeof t == "function" ? t(d) : Bt(d, t),
        children: M
      }
    ) : M ? /* @__PURE__ */ H.jsx(H.Fragment, { children: M }) : null;
    return C ? /* @__PURE__ */ H.jsx(We.Provider, { value: C, children: v }) : v;
  };
  return c.displayName = r.name, fi(c);
}, Vt = ["enabled", "selected"], U = (i) => l({
  name: i.name,
  create(e, t) {
    if (!e.scene)
      return;
    const o = i.create(t, e.scene.postProcessStages);
    return typeof t.enabled == "boolean" && (o.enabled = t.enabled), t.selected && "selected" in o && (o.selected = t.selected), i.props.forEach((r) => {
      !ve(i.readonlyProps, r) && typeof t[r] < "u" && (o.uniforms[r] = t[r]);
    }), !i.noMount && e.scene && !e.scene.isDestroyed() && e.scene.postProcessStages.add(o), o;
  },
  destroy(e, t) {
    i.noMount ? e.enabled = !1 : (t.scene && !t.scene.isDestroyed() && t.scene.postProcessStages.remove(e), e.isDestroyed() || e.destroy());
  },
  update(e, t, o) {
    i.props.forEach((r) => {
      !ve(i.readonlyProps, r) && t[r] !== o[r] && (e.uniforms[r] = t[r]);
    });
  },
  cesiumProps: Vt,
  cesiumReadonlyProps: i.readonlyProps,
  defaultProps: {
    enabled: !0
  }
}), ys = (i) => (
  // supports both functional components and class components
  // eslint-disable-next-line react/display-name
  fi((e, t) => /* @__PURE__ */ H.jsx(_t, { children: (o) => /* @__PURE__ */ H.jsx(i, { ...e, ref: t, cesium: o }) }))
), Ut = [
  "alignedAxis",
  "color",
  "disableDepthTestDistance",
  "distanceDisplayCondition",
  "eyeOffset",
  "height",
  "heightReference",
  "horizontalOrigin",
  "image",
  "pixelOffset",
  "pixelOffsetScaleByDistance",
  "position",
  "rotation",
  "scale",
  "scaleByDistance",
  "show",
  "sizeInMeters",
  "translucencyByDistance",
  "verticalOrigin",
  "width",
  "id"
], jt = l({
  name: "Billboard",
  create(i, e) {
    var t;
    return (t = i.billboardCollection) == null ? void 0 : t.add(e);
  },
  destroy(i, e) {
    e.billboardCollection && !e.billboardCollection.isDestroyed() && e.billboardCollection.remove(i);
  },
  cesiumProps: Ut,
  useCommonEvent: !0
}), ps = jt, Ht = [
  "blendOption",
  "debugShowBoundingVolume",
  "debugShowTextureAtlas",
  "modelMatrix",
  "show"
], zt = l({
  name: "BillboardCollection",
  create(i, e) {
    if (!i.primitiveCollection)
      return;
    const t = new xi({
      modelMatrix: e.modelMatrix,
      debugShowBoundingVolume: e.debugShowBoundingVolume,
      scene: i.scene,
      blendOption: e.blendOption
    });
    return i.primitiveCollection.add(t), t;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  provide(i) {
    return {
      billboardCollection: i
    };
  },
  cesiumProps: Ht
}), vs = zt, xt = [
  "image",
  "show",
  "scale",
  "horizontalOrigin",
  "verticalOrigin",
  "eyeOffset",
  "pixelOffset",
  "rotation",
  "alignedAxis",
  "width",
  "height",
  "color",
  "scaleByDistance",
  "translucencyByDistance",
  "pixelOffsetScaleByDistance",
  "imageSubRegion",
  "sizeInMeters",
  "heightReference",
  "distanceDisplayCondition",
  "disableDepthTestDistance"
], Nt = {
  onDefinitionChange: "definitionChanged"
}, qt = l({
  name: "BillboardGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new Ni(e);
    return i.entity.billboard = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.billboard = void 0);
  },
  cesiumProps: xt,
  cesiumEventProps: Nt
}), gs = qt, Yt = [
  "heightReference",
  "dimensions",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "shadows",
  "distanceDisplayCondition"
], Kt = {
  onDefinitionChange: "definitionChanged"
}, Jt = l({
  name: "BoxGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new qi(e);
    return i.entity.box = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.box = void 0);
  },
  cesiumProps: Yt,
  cesiumEventProps: Kt
}), Cs = Jt, Zt = [
  "position",
  "direction",
  "up",
  "right",
  "frustum",
  "defaultMoveAmount",
  "defaultLookAmount",
  "defaultRotateAmount",
  "defaultZoomAmount",
  "constrainedAxis",
  "maximumZoomFactor",
  "percentageChanged"
], Xt = {
  onChange: "changed",
  onMoveEnd: "moveEnd",
  onMoveStart: "moveStart"
}, Qt = l({
  name: "Camera",
  create: (i) => {
    var e;
    return (e = i.scene) == null ? void 0 : e.camera;
  },
  cesiumProps: Zt,
  cesiumEventProps: Xt,
  setCesiumPropsAfterCreate: !0
}), Ps = Qt, en = Te(
  "CameraFlyHome",
  (i, { duration: e }) => {
    i.flyHome(e);
  }
), Ss = en, tn = Te(
  "CameraFlyTo",
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  (i, { onComplete: e, onCancel: t, ...o }) => {
    i.flyTo({ ...o, complete: e, cancel: t });
  }
), Es = tn, nn = Te(
  "CameraLookAt",
  (i, { target: e, offset: t }) => {
    i.lookAt(e, t);
  }
), bs = nn, on = Te(
  "CameraFlyToBoundingSphere",
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  (i, { boundingSphere: e, onComplete: t, onCancel: o, ...r }) => {
    i.flyToBoundingSphere(e, {
      ...r,
      complete: t,
      cancel: o
    });
  }
), ws = on, rn = [
  "show",
  "modelMatrix",
  "shadows",
  "maximumScreenSpaceError",
  "cullRequestsWhileMoving",
  "cullRequestsWhileMovingMultiplier",
  "preloadWhenHidden",
  "preloadFlightDestinations",
  "preferLeaves",
  "progressiveResolutionHeightFraction",
  "foveatedScreenSpaceError",
  "foveatedConeSize",
  "foveatedMinimumScreenSpaceErrorRelaxation",
  "foveatedInterpolationCallback",
  "foveatedTimeDelay",
  "dynamicScreenSpaceError",
  "dynamicScreenSpaceErrorDensity",
  "dynamicScreenSpaceErrorFactor",
  "dynamicScreenSpaceErrorHeightFalloff",
  "skipLevelOfDetail",
  "baseScreenSpaceError",
  "skipScreenSpaceErrorFactor",
  "skipLevels",
  "immediatelyLoadDesiredLevelOfDetail",
  "loadSiblings",
  "clippingPlanes",
  "classificationType",
  "ellipsoid",
  "lightColor",
  "colorBlendAmount",
  "colorBlendMode",
  "debugFreezeFrame",
  "debugColorizeTiles",
  "debugWireframe",
  "debugShowBoundingVolume",
  "debugShowContentBoundingVolume",
  "debugShowViewerRequestVolume",
  "debugShowGeometricError",
  "debugShowRenderingStatistics",
  "debugShowMemoryUsage",
  "debugShowUrl",
  "style",
  "backFaceCulling",
  "vectorClassificationOnly",
  "vectorKeepDecodedPositions",
  "splitDirection",
  "customShader",
  "imageBasedLighting",
  "showCreditsOnScreen",
  "featureIdLabel",
  "instanceFeatureIdLabel",
  "imageBasedLighting",
  "outlineColor",
  "cacheBytes",
  "maximumCacheOverflowBytes",
  "enableCollision"
], sn = [
  "showOutline",
  "cullWithChildrenBounds",
  "debugHeatmapTilePropertyName",
  "enableDebugWireframe",
  "modelUpAxis",
  "modelForwardAxis",
  "projectTo2D",
  "enableShowOutline",
  "enablePick"
], an = {
  onAllTilesLoad: "allTilesLoaded",
  onInitialTilesLoad: "initialTilesLoaded",
  onLoadProgress: "loadProgress",
  onTileFailed: "tileFailed",
  onTileLoad: "tileLoad",
  onTileUnload: "tileUnload",
  onTileVisible: "tileVisible"
}, cn = ["onReady", "onError", "url"], ln = l({
  name: "Cesium3DTileset",
  async create(i, e) {
    var c, u;
    if (!i.primitiveCollection)
      return;
    const t = e.url;
    let o;
    J(t) ? o = await t : o = t;
    let r;
    try {
      r = await Yi.fromUrl(o, e), (c = e.onReady) == null || c.call(e, r);
    } catch (h) {
      (u = e.onError) == null || u.call(e, h);
      return;
    }
    return e.colorBlendAmount && (r.colorBlendAmount = e.colorBlendAmount), e.colorBlendMode && (r.colorBlendMode = e.colorBlendMode), e.style && (r.style = e.style), i.primitiveCollection.add(r), r;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: rn,
  cesiumReadonlyProps: sn,
  cesiumEventProps: an,
  otherProps: cn,
  useCommonEvent: !0
}), Ds = ln, un = ["show", "uri", "maximumScreenSpaceError"], dn = {
  onDefinitionChange: "definitionChanged"
}, mn = l({
  name: "Cesium3DTilesetGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new Ki(e);
    return i.entity.tileset = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.tileset = void 0);
  },
  cesiumProps: un,
  cesiumEventProps: dn
}), Rs = mn, fn = [
  "resolutionScale",
  "useDefaultRenderLoop",
  "targetFrameRate",
  "useBrowserRecommendedResolution",
  "creditDisplay"
], hn = [
  "clock",
  "baseLayer",
  "terrainProvider",
  "skyBox",
  "skyAtmosphere",
  "sceneMode",
  "scene3DOnly",
  "orderIndependentTranslucency",
  "mapMode2D",
  "mapProjection",
  "globe",
  "showRenderLoopErrors",
  "contextOptions",
  "creditContainer",
  "creditViewport",
  "shadows",
  "terrainShadows",
  "terrain",
  "requestRenderMode",
  "maximumRenderTimeChange",
  "msaaSamples",
  "blurActiveElementOnCanvasFocus"
], yn = ["className", "id", "style", "full", "containerProps"], pn = l({
  name: "CesiumWidget",
  create(i, e, t) {
    if (!t)
      return;
    const o = new Ji(t, e);
    if (!o)
      return;
    typeof e.resolutionScale == "number" && (o.resolutionScale = e.resolutionScale);
    const r = new De(o.scene);
    return [o, r];
  },
  destroy(i, e, t, o) {
    o && !o.isDestroyed() && o.destroy(), i.isDestroyed() || i.destroy();
  },
  provide(i, e, t, o) {
    return {
      cesiumWidget: i,
      scene: i.scene,
      camera: i.scene.camera,
      imageryLayerCollection: i.scene.globe.imageryLayers,
      primitiveCollection: i.scene.primitives,
      globe: i.scene.globe,
      __$internal: {
        onUpdate: t == null ? void 0 : t.onUpdate
      },
      [ce]: o
    };
  },
  containerProps: ({ id: i, className: e, style: t, full: o, containerProps: r }) => ({
    className: e,
    id: i,
    style: {
      ...o ? {
        position: "absolute",
        bottom: "0",
        left: "0",
        right: "0",
        top: "0"
      } : {},
      ...t
    },
    ...r
  }),
  cesiumProps: fn,
  cesiumReadonlyProps: hn,
  otherProps: yn,
  renderContainer: !0,
  useCommonEvent: !0,
  useRootEvent: !0
}), $s = pn, vn = [
  "classificationType",
  "debugShowBoundingVolume",
  "debugShowShadowVolume",
  "show"
], gn = [
  "allowPicking",
  "asynchronous",
  "compressVertices",
  "geometryInstances",
  "interleave",
  "releaseGeometryInstances",
  "vertexCacheOptimize",
  "appearance"
], Cn = ["onReady"], Pn = l({
  name: "ClassificationPrimitive",
  async create(i, e) {
    var o;
    if (!i.primitiveCollection)
      return;
    const t = new Zi(e);
    if (e.onReady) {
      const r = () => {
        var c, u;
        t.ready && ((c = e.onReady) == null || c.call(e, t), (u = i.scene) == null || u.postRender.removeEventListener(r));
      };
      (o = i.scene) == null || o.postRender.addEventListener(r);
    }
    return i.primitiveCollection.add(t), t;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: vn,
  cesiumReadonlyProps: gn,
  otherProps: Cn,
  useCommonEvent: !0
}), Ts = Pn, Sn = {
  onStop: "onStop",
  onTick: "onTick"
}, En = [
  "canAnimate",
  "clockRange",
  "clockStep",
  "currentTime",
  "multiplier",
  "shouldAnimate",
  "startTime",
  "stopTime"
], bn = l({
  name: "Clock",
  create: (i) => {
    var e;
    return (e = i.cesiumWidget) == null ? void 0 : e.clock;
  },
  cesiumProps: En,
  cesiumEventProps: Sn,
  setCesiumPropsAfterCreate: !0
}), Ms = bn, wn = [
  "noiseDetail",
  "noiseOffset",
  "show",
  "debugBillboards",
  "debugEllipsoids"
], Dn = l({
  name: "CloudCollection",
  create: (i) => {
    if (!i.primitiveCollection)
      return;
    const e = new Xi();
    return i.primitiveCollection.add(e), e;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  provide: (i) => ({
    cloudCollection: i
  }),
  cesiumProps: wn,
  setCesiumPropsAfterCreate: !0
}), ks = Dn, Rn = [
  "positions",
  "width",
  "cornerType",
  "height",
  "heightReference",
  "extrudedHeight",
  "extrudedHeightReference",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "granularity",
  "shadows",
  "distanceDisplayCondition",
  "zIndex",
  "classificationType"
], $n = {
  onDefinitionChange: "definitionChanged"
}, Tn = l({
  name: "CorridorGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new Qi(e);
    return e.classificationType && (t.classificationType = e.classificationType), i.entity.corridor = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.corridor = void 0);
  },
  cesiumProps: Rn,
  cesiumEventProps: $n
}), Ls = Tn, Mn = [
  "show",
  "position",
  "scale",
  "maximumSize",
  "slice",
  "brightness",
  "color"
], kn = l({
  name: "CumulusCloud",
  create: (i, e) => {
    var t;
    return (t = i.cloudCollection) == null ? void 0 : t.add(e);
  },
  destroy(i, e) {
    e.cloudCollection && !e.cloudCollection.isDestroyed() && e.cloudCollection.remove(i);
  },
  cesiumProps: Mn
}), _s = kn, Ln = ["clustering", "name", "show", "clock", "isLoading"], _n = {
  onChange: "changedEvent",
  onError: "errorEvent",
  onLoading: "loadingEvent"
}, On = l({
  name: "CustomDataSource",
  create(i, e) {
    if (!i.dataSourceCollection)
      return;
    const t = new et(e.name);
    return e.clustering && (t.clustering = e.clustering), typeof e.show == "boolean" && (t.show = e.show), typeof e.clock < "u" && (t.clock = e.clock), i.dataSourceCollection.add(t), t;
  },
  destroy(i, e) {
    e.dataSourceCollection && !e.dataSourceCollection.isDestroyed() && e.dataSourceCollection.remove(i);
  },
  provide(i) {
    return {
      entityCollection: i.entities,
      dataSource: i
    };
  },
  cesiumProps: Ln,
  cesiumEventProps: _n,
  useCommonEvent: !0
}), Os = On, Gn = [
  "heightReference",
  "length",
  "topRadius",
  "bottomRadius",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "numberOfVerticalLines",
  "slices",
  "distanceDisplayCondition",
  "shadows"
], Bn = {
  onDefinitionChange: "definitionChanged"
}, An = l({
  name: "CylinderGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new it(e);
    return i.entity.cylinder = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.cylinder = void 0);
  },
  cesiumProps: Gn,
  cesiumEventProps: Bn
}), Gs = An, Fn = ["clustering", "show"], In = ["name", "sourceUri", "credit"], Wn = {
  onChange: "changedEvent",
  onError: "errorEvent",
  onLoading: "loadingEvent"
}, Vn = ["onLoad", "data"], ai = (i, { data: e, onLoad: t, ...o }) => {
  e && i.load(e, o).then((r) => {
    t && t(r);
  });
}, Un = l({
  name: "CzmlDataSource",
  create(i, e) {
    if (!i.dataSourceCollection)
      return;
    const t = new tt(e.name);
    return e.clustering && (t.clustering = e.clustering), typeof e.show == "boolean" && (t.show = e.show), i.dataSourceCollection.add(t), e.data && ai(t, e), t;
  },
  update(i, e, t) {
    e.data ? t.show !== e.show && (i.show = typeof e.show == "boolean" ? e.show : !0) : i.show = !1, e.data && (t.data !== e.data || t.sourceUri !== e.sourceUri || t.credit !== e.credit) && ai(i, e);
  },
  destroy(i, e) {
    e.dataSourceCollection && !e.dataSourceCollection.isDestroyed() && e.dataSourceCollection.remove(i);
  },
  provide(i) {
    return {
      dataSource: i
    };
  },
  cesiumProps: Fn,
  cesiumReadonlyProps: In,
  cesiumEventProps: Wn,
  otherProps: Vn,
  useCommonEvent: !0
}), Bs = Un, jn = [
  "semiMajorAxis",
  "semiMinorAxis",
  "height",
  "heightReference",
  "extrudedHeight",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "numberOfVerticalLines",
  "rotation",
  "stRotation",
  "granularity",
  "shadows",
  "distanceDisplayCondition",
  "zIndex",
  "classificationType",
  "extrudedHeightReference"
], Hn = {
  onDefinitionChange: "definitionChanged"
}, zn = l({
  name: "EllipseGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new nt(e);
    return i.entity.ellipse = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.ellipse = void 0);
  },
  cesiumProps: jn,
  cesiumEventProps: Hn
}), As = zn, xn = [
  "heightReference",
  "radii",
  "show",
  "fill",
  "innerRadii",
  "material",
  "maximumClock",
  "maximumCone",
  "minimumClock",
  "minimumCone",
  "outline",
  "outlineColor",
  "outlineWidth",
  "subdivisions",
  "stackPartitions",
  "slicePartitions",
  "shadows",
  "distanceDisplayCondition"
], Nn = {
  onDefinitionChange: "definitionChanged"
}, qn = l({
  name: "EllipsoidGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new ot(e);
    return i.entity.ellipsoid = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.ellipsoid = void 0);
  },
  cesiumProps: xn,
  cesiumEventProps: Nn
}), Fs = qn, Yn = [
  "availability",
  "billboard",
  "box",
  "corridor",
  "cylinder",
  "description",
  "ellipse",
  "ellipsoid",
  "entityCollection",
  "label",
  "model",
  "name",
  "orientation",
  "path",
  "plane",
  "parent",
  "point",
  "polygon",
  "polyline",
  "polylineVolume",
  "position",
  "properties",
  "rectangle",
  "show",
  "tileset",
  "viewFrom",
  "wall"
], Kn = ["id"], Jn = {
  onDefinitionChange: "definitionChanged"
}, Zn = ["selected", "tracked"], Xn = l({
  name: "Entity",
  create(i, e) {
    if (!i.entityCollection)
      return;
    const t = new rt(e);
    return i.viewer && e.selected && (i.viewer.selectedEntity = t), i.viewer && e.tracked && (i.viewer.trackedEntity = t), i.entityCollection.add(t), t;
  },
  destroy(i, e) {
    e.entityCollection && e.entityCollection.remove(i);
  },
  update(i, e, t, o) {
    o.viewer && (e.selected !== t.selected && (e.selected ? o.viewer.selectedEntity = i : o.viewer.selectedEntity === i && (o.viewer.selectedEntity = void 0)), e.tracked !== t.tracked && (e.tracked ? o.viewer.trackedEntity = i : o.viewer.trackedEntity === i && (o.viewer.trackedEntity = void 0)));
  },
  provide(i, e, t) {
    return {
      entity: i,
      __$internal: {
        onUpdate: t == null ? void 0 : t.onUpdate
      }
    };
  },
  cesiumProps: Yn,
  cesiumReadonlyProps: Kn,
  cesiumEventProps: Jn,
  otherProps: Zn,
  useCommonEvent: !0
}), Is = Xn, Qn = ({
  children: i,
  container: e,
  resizeInfoBox: t = !0
}) => {
  const { viewer: o, entity: r } = $e(), [c, u] = mi(!1), h = zi(
    () => {
      var d;
      return e ?? ((d = o == null ? void 0 : o.infoBox.frame.contentDocument) == null ? void 0 : d.createElement("div"));
    },
    [e, o == null ? void 0 : o.infoBox.frame.contentDocument]
  );
  return le(() => {
    if (!o || !r)
      return;
    const d = (C) => {
      u(!!C && C.id === r.id);
    };
    return o.selectedEntityChanged.addEventListener(d), () => {
      o.selectedEntityChanged.removeEventListener(d);
    };
  }, [r, o]), le(() => {
    var T, M;
    if (e || !h || !o)
      return;
    const d = (T = o.infoBox) == null ? void 0 : T.frame, C = (M = d == null ? void 0 : d.contentDocument) == null ? void 0 : M.querySelector(".cesium-infoBox-description");
    if (!d || !C)
      return;
    let y;
    if (c) {
      if (t) {
        const v = C.getBoundingClientRect().height;
        d.style.height = v + "px", y = window.setInterval(() => {
          const k = o.infoBox.container.querySelector(
            ".cesium-infoBox.cesium-infoBox-visible"
          );
          k && (clearInterval(y), y = void 0, C.appendChild(h), k.classList.remove("cesium-infoBox-bodyless"), d.style.height = C.getBoundingClientRect().height + "px");
        }, 10);
      }
    } else
      h.parentElement === C && C.removeChild(h);
    return y ? () => clearTimeout(y) : void 0;
  }, [h, e, t, c, o]), h ? /* @__PURE__ */ H.jsx(H.Fragment, { children: Lt(/* @__PURE__ */ H.jsx(H.Fragment, { children: !e || c ? i : null }), h) }) : null;
}, Ws = Qn, eo = [
  "density",
  "enabled",
  "minimumBrightness",
  "screenSpaceErrorFactor",
  "renderable"
], io = l({
  name: "Fog",
  create(i) {
    if (!i.scene)
      return;
    const e = new ii();
    return i.scene.fog = e, e;
  },
  destroy(i, e) {
    e.scene && !e.scene.isDestroyed() && (e.scene.fog = new ii());
  },
  cesiumProps: eo,
  setCesiumPropsAfterCreate: !0
}), Vs = io, to = ["clustering", "name", "show"], no = [
  "clampToGround",
  "sourceUri",
  "credit",
  "markerSize",
  "markerSymbol",
  "markerColor",
  "stroke",
  "strokeWidth",
  "fill",
  "describe"
], oo = {
  onChange: "changedEvent",
  onError: "errorEvent",
  onLoading: "loadingEvent"
}, ro = ["onLoad", "data"], ci = (i, { data: e, onLoad: t, ...o }) => {
  e && i.load(e, o).then((r) => {
    t && t(r);
  });
}, so = l({
  name: "GeoJsonDataSource",
  create(i, e) {
    if (!i.dataSourceCollection)
      return;
    const t = new st(e.name);
    return e.clustering && (t.clustering = e.clustering), typeof e.show == "boolean" && (t.show = e.show), i.dataSourceCollection.add(t), e.data && ci(t, e), t;
  },
  update(i, e, t) {
    e.data ? t.show !== e.show && (i.show = typeof e.show == "boolean" ? e.show : !0) : i.show = !1, e.data && (t.data !== e.data || t.clampToGround !== e.clampToGround || t.sourceUri !== e.sourceUri || t.credit !== e.credit || t.markerSize !== e.markerSize || t.markerSymbol !== e.markerSymbol || t.markerColor !== e.markerColor || t.stroke !== e.stroke || t.strokeWidth !== e.strokeWidth || t.fill !== e.fill) && ci(i, e);
  },
  destroy(i, e) {
    e.dataSourceCollection && !e.dataSourceCollection.isDestroyed() && e.dataSourceCollection.remove(i);
  },
  provide(i) {
    return {
      dataSource: i
    };
  },
  cesiumProps: to,
  cesiumReadonlyProps: no,
  cesiumEventProps: oo,
  otherProps: ro,
  useCommonEvent: !0
}), Us = so, ao = {
  onImageryLayersUpdate: "imageryLayersUpdatedEvent",
  onTerrainProviderChange: "terrainProviderChanged",
  onTileLoadProgress: "tileLoadProgressEvent"
}, co = [
  "atmosphereBrightnessShift",
  "atmosphereHueShift",
  "atmosphereSaturationShift",
  "backFaceCulling",
  "baseColor",
  "clippingPlanes",
  "depthTestAgainstTerrain",
  "enableLighting",
  "lightingFadeInDistance",
  "lightingFadeOutDistance",
  "material",
  "maximumScreenSpaceError",
  "nightFadeInDistance",
  "nightFadeOutDistance",
  "oceanNormalMapUrl",
  "shadows",
  "show",
  "showGroundAtmosphere",
  "showWaterEffect",
  "tileCacheSize",
  "loadingDescendantLimit",
  "preloadAncestors",
  "preloadSiblings",
  "fillHighlightColor",
  "dynamicAtmosphereLighting",
  "dynamicAtmosphereLightingFromSun",
  "showSkirts",
  "cartographicLimitRectangle",
  "translucency",
  "undergroundColor",
  "undergroundColorAlphaByDistance",
  "lambertDiffuseMultiplier",
  "atmosphereLightIntensity",
  "atmosphereRayleighCoefficient",
  "atmosphereMieCoefficient",
  "atmosphereRayleighScaleHeight",
  "atmosphereMieScaleHeight",
  "atmosphereMieAnisotropy",
  "vertexShadowDarkness"
], lo = ["terrainProvider"], uo = l({
  name: "Globe",
  create: (i) => {
    var e;
    return (e = i.scene) == null ? void 0 : e.globe;
  },
  update: async (i, e) => {
    const t = e.terrainProvider;
    let o;
    J(t) ? o = await t : o = t, i.terrainProvider = o;
  },
  cesiumProps: co,
  cesiumEventProps: ao,
  otherProps: lo,
  setCesiumPropsAfterCreate: !0
}), js = uo, mo = [
  "appearance",
  "classificationType",
  "debugShowBoundingVolume",
  "debugShowShadowVolume",
  "show"
], fo = [
  "allowPicking",
  "asynchronous",
  "geometryInstances",
  "interleave",
  "releaseGeometryInstances"
], ho = ["onReady"], yo = l({
  name: "GroundPolylinePrimitive",
  create(i, e) {
    var o;
    if (!i.primitiveCollection)
      return;
    const t = new at(e);
    if (e.onReady) {
      const r = () => {
        var c, u;
        t.ready && ((c = e.onReady) == null || c.call(e, t), (u = i.scene) == null || u.postRender.removeEventListener(r));
      };
      (o = i.scene) == null || o.postRender.addEventListener(r);
    }
    return i.primitiveCollection.add(t), t;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: mo,
  cesiumReadonlyProps: fo,
  otherProps: ho,
  useCommonEvent: !0
}), Hs = yo, po = [
  "appearance",
  "classificationType",
  "debugShowBoundingVolume",
  "debugShowShadowVolume",
  "show"
], vo = [
  "allowPicking",
  "asynchronous",
  "compressVertices",
  "geometryInstances",
  "interleave",
  "releaseGeometryInstances",
  "vertexCacheOptimize"
], go = ["onReady"], Co = l({
  name: "GroundPrimitive",
  create(i, e) {
    var o;
    if (!i.primitiveCollection)
      return;
    const t = new ct(e);
    if (e.onReady) {
      const r = () => {
        var c, u;
        t.ready && ((c = e.onReady) == null || c.call(e, t), (u = i.scene) == null || u.postRender.removeEventListener(r));
      };
      (o = i.scene) == null || o.postRender.addEventListener(r);
    }
    return i.primitiveCollection.add(t), t;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: po,
  cesiumReadonlyProps: vo,
  otherProps: go,
  useCommonEvent: !0
}), zs = Co, Po = ["show", "destroyPrimitives", "primitiveAdded", "primitiveRemoved"], So = l({
  name: "GroundPrimitiveCollection",
  create: (i) => {
    var e;
    return (e = i.scene) == null ? void 0 : e.groundPrimitives;
  },
  provide: (i) => ({
    primitiveCollection: i
  }),
  cesiumProps: Po,
  setCesiumPropsAfterCreate: !0
}), xs = So, Eo = [
  "alpha",
  "brightness",
  "contrast",
  "hue",
  "saturation",
  "gamma",
  "splitDirection",
  "minificationFilter",
  "magnificationFilter",
  "cutoutRectangle",
  "show",
  "nightAlpha",
  "dayAlpha",
  "colorToAlpha",
  "colorToAlphaThreshold",
  "index"
], bo = [
  "rectangle",
  "maximumAnisotropy",
  "minimumTerrainLevel",
  "maximumTerrainLevel",
  "readyEvent",
  "imageryProvider"
], wo = l({
  name: "ImageryLayer",
  async create(i, e) {
    var u, h, d, C;
    if (!i.imageryLayerCollection)
      return;
    const t = J(e.imageryProvider) ? e.imageryProvider : new Promise((y) => queueMicrotask(() => y(e.imageryProvider))), o = (h = (u = i.__$internal) == null ? void 0 : u.imageryLayerWaitingList) == null ? void 0 : h.slice();
    (d = i.__$internal) != null && d.imageryLayerWaitingList && i.__$internal.imageryLayerWaitingList.push(t), o && await Promise.all(o.filter((y) => J(y)));
    const r = await t;
    if ((C = i.__$internal) != null && C.imageryLayerWaitingList && (i.__$internal.imageryLayerWaitingList = i.__$internal.imageryLayerWaitingList.filter((y) => y !== t)), !r)
      return;
    const c = new lt(r, e);
    return i.imageryLayerCollection.add(c, e.index), c;
  },
  destroy(i, e) {
    e.imageryLayerCollection && e.imageryLayerCollection.remove(i);
  },
  cesiumProps: Eo,
  cesiumReadonlyProps: bo
}), Ns = wo, Do = {
  onLayerAdd: "layerAdded",
  onLayerMove: "layerMoved",
  onLayerRemove: "layerRemoved",
  onLayerShowOrHide: "layerShownOrHidden"
}, Ro = l({
  name: "ImageryLayerCollection",
  create: (i) => {
    var e;
    return (e = i.globe) == null ? void 0 : e.imageryLayers;
  },
  cesiumEventProps: Do
}), qs = Ro, $o = ["clustering", "name", "show"], To = [
  "canvas",
  "camera",
  "ellipsoid",
  "clampToGround",
  "sourceUri",
  "credit",
  "screenOverlayContainer"
], Mo = {
  onChange: "changedEvent",
  onError: "errorEvent",
  onLoading: "loadingEvent",
  onRefresh: "refreshEvent",
  onUnsupportedNode: "unsupportedNodeEvent"
}, ko = ["onLoad", "data"], li = (i, { data: e, onLoad: t, ...o }) => {
  e && i.load(e, o).then((r) => {
    t && t(r);
  });
}, Lo = l({
  name: "KmlDataSource",
  create(i, e) {
    if (!i.scene || !i.dataSourceCollection || !i.scene)
      return;
    const t = new ut({
      camera: e.camera || i.scene.camera,
      canvas: e.canvas || i.scene.canvas,
      ellipsoid: e.ellipsoid,
      credit: e.credit
    });
    return e.clustering && (t.clustering = e.clustering), typeof e.show == "boolean" && (t.show = e.show), typeof e.name < "u" && (t.name = e.name), i.dataSourceCollection.add(t), e.data && li(t, e), t;
  },
  update(i, e, t) {
    e.data ? t.show !== e.show && (i.show = typeof e.show == "boolean" ? e.show : !0) : i.show = !1, e.data && (t.data !== e.data || t.clampToGround !== e.clampToGround || t.ellipsoid !== e.ellipsoid || t.sourceUri !== e.sourceUri || t.credit !== e.credit) && li(i, e);
  },
  destroy(i, e) {
    e.dataSourceCollection && !e.dataSourceCollection.isDestroyed() && e.dataSourceCollection.remove(i);
  },
  provide(i) {
    return {
      dataSource: i
    };
  },
  cesiumProps: $o,
  cesiumReadonlyProps: To,
  cesiumEventProps: Mo,
  otherProps: ko,
  useCommonEvent: !0
}), Ys = Lo, _o = [
  "backgroundColor",
  "backgroundPadding",
  "disableDepthTestDistance",
  "distanceDisplayCondition",
  "eyeOffset",
  "fillColor",
  "font",
  "heightReference",
  "horizontalOrigin",
  "id",
  "outlineColor",
  "outlineWidth",
  "pixelOffset",
  "pixelOffsetScaleByDistance",
  "position",
  "scale",
  "scaleByDistance",
  "show",
  "showBackground",
  "style",
  "text",
  "translucencyByDistance",
  "verticalOrigin"
], Oo = l({
  name: "Label",
  create: (i, e) => {
    var t;
    return (t = i.labelCollection) == null ? void 0 : t.add(e);
  },
  destroy(i, e) {
    e.labelCollection && !e.labelCollection.isDestroyed() && e.labelCollection.remove(i);
  },
  cesiumProps: _o,
  useCommonEvent: !0
}), Ks = Oo, Go = ["blendOption", "debugShowBoundingVolume", "modelMatrix", "show"], Bo = l({
  name: "LabelCollection",
  create(i, e) {
    if (!i.scene || !i.primitiveCollection)
      return;
    const t = new dt({
      scene: i.scene,
      modelMatrix: e.modelMatrix,
      blendOption: e.blendOption,
      debugShowBoundingVolume: e.debugShowBoundingVolume
    });
    return i.primitiveCollection.add(t), t;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  provide(i) {
    return {
      labelCollection: i
    };
  },
  cesiumProps: Go
}), Js = Bo, Ao = [
  "text",
  "font",
  "style",
  "fillColor",
  "outlineColor",
  "outlineWidth",
  "show",
  "showBackground",
  "backgroundColor",
  "backgroundPadding",
  "scale",
  "horizontalOrigin",
  "verticalOrigin",
  "eyeOffset",
  "pixelOffset",
  "translucencyByDistance",
  "pixelOffsetScaleByDistance",
  "scaleByDistance",
  "heightReference",
  "distanceDisplayCondition",
  "disableDepthTestDistance"
], Fo = {
  onDefinitionChange: "definitionChanged"
}, Io = l({
  name: "LabelGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new mt(e);
    return i.entity.label = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.label = void 0);
  },
  cesiumProps: Ao,
  cesiumEventProps: Fo
}), Zs = Io, Wo = [
  "backFaceCulling",
  "clampAnimations",
  "clippingPlanes",
  "color",
  "colorBlendAmount",
  "colorBlendMode",
  "customShader",
  "debugShowBoundingVolume",
  "debugWireframe",
  "distanceDisplayCondition",
  "featureIdLabel",
  "heightReference",
  "id",
  "imageBasedLighting",
  "instanceFeatureIdLabel",
  "lightColor",
  "maximumScale",
  "minimumPixelSize",
  "modelMatrix",
  "outlineColor",
  "scale",
  "shadows",
  "show",
  "showCreditsOnScreen",
  "showOutline",
  "silhouetteColor",
  "silhouetteSize",
  "splitDirection",
  "style"
], Vo = [
  "allowPicking",
  "asynchronous",
  "basePath",
  "credit",
  "enableDebugWireframe",
  "gltf",
  "heightReference",
  "incrementallyLoadTextures",
  "scene",
  "releaseGltfJson",
  "cull",
  "opaquePass",
  "upAxis",
  "forwardAxis",
  "content",
  "scene",
  "enableShowOutline",
  "projectTo2D",
  "classificationType",
  "errorEvent",
  "readyEvent",
  "texturesReadyEvent",
  "gltfCallback",
  "enablePick"
], Uo = ["onReady", "onError", "url"], jo = l({
  name: "Model",
  async create(i, { scene: e, url: t, colorBlendMode: o, ...r }) {
    var d;
    if (!i.scene || !i.primitiveCollection || !t)
      return;
    const c = t;
    let u;
    J(c) ? u = await c : u = c;
    let h;
    try {
      h = await ft.fromGltfAsync({
        ...r,
        url: u,
        colorBlendMode: o,
        scene: e || i.scene
      });
    } catch (C) {
      (d = r.onError) == null || d.call(r, C);
      return;
    }
    return i.primitiveCollection.add(h), h;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumEventProps: {
    onReady: "readyEvent"
  },
  cesiumProps: Wo,
  cesiumReadonlyProps: Vo,
  otherProps: Uo,
  useCommonEvent: !0
}), Xs = jo, Ho = [
  "uri",
  "show",
  "scale",
  "minimumPixelSize",
  "maximumScale",
  "incrementallyLoadTextures",
  "runAnimations",
  "clampAnimations",
  "nodeTransformations",
  "shadows",
  "heightReference",
  "distanceDisplayCondition",
  "silhouetteColor",
  "silhouetteSize",
  "color",
  "colorBlendMode",
  "colorBlendAmount",
  "clippingPlanes",
  "imageBasedLightingFactor",
  "lightColor",
  "articulations",
  "customShader"
], zo = {
  onDefinitionChange: "definitionChanged"
}, xo = l({
  name: "ModelGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new ht(e);
    return i.entity.model = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.model = void 0);
  },
  cesiumProps: Ho,
  cesiumEventProps: zo
}), Qs = xo, No = ["onlySunLighting", "show", "textureUrl"], qo = ["ellipsoid"], Yo = l({
  name: "Moon",
  create(i, e) {
    if (!i.scene)
      return;
    const t = new ti(e);
    return i.scene.moon = t, t;
  },
  destroy(i, e) {
    e.scene && !e.scene.isDestroyed() && (e.scene.moon = new ti());
  },
  cesiumProps: No,
  cesiumReadonlyProps: qo
}), ea = Yo, Ko = [
  "show",
  "emitter",
  "modelMatrix",
  "emitterModelMatrix",
  "emissionRate",
  "bursts",
  "loop",
  "startScale",
  "endScale",
  "startColor",
  "endColor",
  "image",
  "imageSize",
  "minimumImageSize",
  "maximumImageSize",
  "speed",
  "minimumSpeed",
  "maximumSpeed",
  "lifetime",
  "particleLife",
  "minimumParticleLife",
  "maximumParticleLife",
  "mass",
  "minimumMass",
  "maximumMass",
  "sizeInMeters"
], Jo = {
  onComplete: "complete",
  onUpdate: "updateCallback"
}, Zo = l({
  name: "ParticleSystem",
  create(i, e) {
    if (!i.primitiveCollection)
      return;
    const t = new yt({ ...e, updateCallback: e.onUpdate });
    return i.primitiveCollection.add(t), t;
  },
  update(i, e, t) {
    e.onUpdate !== t.onUpdate && (i.updateCallback = e.onUpdate);
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i);
  },
  cesiumProps: Ko,
  cesiumEventProps: Jo
}), ia = Zo, Xo = [
  "leadTime",
  "trailTime",
  "show",
  "width",
  "material",
  "resolution",
  "distanceDisplayCondition"
], Qo = {
  onDefinitionChange: "definitionChanged"
}, er = l({
  name: "PathGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new pt(e);
    return i.entity.path = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.path = void 0);
  },
  cesiumProps: Xo,
  cesiumEventProps: Qo
}), ta = er, ir = [
  "plane",
  "dimensions",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "shadows",
  "distanceDisplayCondition"
], tr = {
  onDefinitionChange: "definitionChanged"
}, nr = l({
  name: "PlaneGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new vt(e);
    return i.entity.plane = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.plane = void 0);
  },
  cesiumProps: ir,
  cesiumEventProps: tr
}), na = nr, or = [
  "color",
  "pixelSize",
  "outlineColor",
  "outlineWidth",
  "show",
  "scaleByDistance",
  "translucencyByDistance",
  "heightReference",
  "distanceDisplayCondition",
  "disableDepthTestDistance"
], rr = {
  onDefinitionChange: "definitionChanged"
}, sr = l({
  name: "PointGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new gt(e);
    return i.entity.point = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.point = void 0);
  },
  cesiumProps: or,
  cesiumEventProps: rr
}), oa = sr, ar = [
  "color",
  "disableDepthTestDistance",
  "distanceDisplayCondition",
  "id",
  "outlineColor",
  "outlineWidth",
  "pixelSize",
  "position",
  "scaleByDistance",
  "show",
  "translucencyByDistance"
], cr = l({
  name: "PointPrimitive",
  create: (i, e) => {
    var t;
    return (t = i.pointPrimitiveCollection) == null ? void 0 : t.add(e);
  },
  destroy(i, e) {
    e.pointPrimitiveCollection && !e.pointPrimitiveCollection.isDestroyed() && e.pointPrimitiveCollection.remove(i);
  },
  cesiumProps: ar,
  useCommonEvent: !0
}), ra = cr, lr = ["blendOption", "debugShowBoundingVolume", "modelMatrix", "show"], ur = l({
  name: "PointPrimitveCollection",
  create(i, e) {
    if (!i.primitiveCollection)
      return;
    const t = new Ct(e);
    return i.primitiveCollection.add(t), t;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  provide(i) {
    return {
      pointPrimitiveCollection: i
    };
  },
  cesiumProps: lr
}), sa = ur, dr = [
  "arcType",
  "hierarchy",
  "height",
  "heightReference",
  "extrudedHeight",
  "extrudedHeightReference",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "stRotation",
  "granularity",
  "perPositionHeight",
  "closeTop",
  "closeBottom",
  "shadows",
  "distanceDisplayCondition",
  "zIndex",
  "classificationType",
  "textureCoordinates"
], mr = {
  onDefinitionChange: "definitionChanged"
}, fr = l({
  name: "PolygonGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new Pt(e);
    return i.entity.polygon = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.polygon = void 0);
  },
  cesiumProps: dr,
  cesiumEventProps: mr
}), aa = fr, hr = [
  "distanceDisplayCondition",
  "id",
  "loop",
  "material",
  "positions",
  "show",
  "width"
], yr = l({
  name: "Polyline",
  create: (i, e) => {
    var t;
    return (t = i.polylineCollection) == null ? void 0 : t.add(e);
  },
  destroy(i, e) {
    e.polylineCollection && !e.polylineCollection.isDestroyed() && e.polylineCollection.remove(i);
  },
  cesiumProps: hr,
  useCommonEvent: !0
}), ca = yr, pr = ["debugShowBoundingVolume", "length", "modelMatrix", "show"], vr = l(
  {
    name: "PolylineCollection",
    create(i, e) {
      if (!i.primitiveCollection)
        return;
      const t = new St({
        modelMatrix: e.modelMatrix,
        debugShowBoundingVolume: e.debugShowBoundingVolume,
        length: e.length,
        scene: i.scene
      });
      return i.primitiveCollection.add(t), t;
    },
    destroy(i, e) {
      e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
    },
    provide(i) {
      return {
        polylineCollection: i
      };
    },
    cesiumProps: pr
  }
), la = vr, gr = [
  "arcType",
  "classificationType",
  "positions",
  "clampToGround",
  "width",
  "show",
  "material",
  "depthFailMaterial",
  "granularity",
  "shadows",
  "distanceDisplayCondition",
  "zIndex"
], Cr = {
  onDefinitionChange: "definitionChanged"
}, Pr = l({
  name: "PolylineGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new Et(e);
    return i.entity.polyline = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.polyline = void 0);
  },
  cesiumProps: gr,
  cesiumEventProps: Cr
}), ua = Pr, Sr = [
  "positions",
  "shape",
  "cornerType",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "granularity",
  "shadows",
  "distanceDisplayCondition"
], Er = {
  onDefinitionChange: "definitionChanged"
}, br = l({
  name: "PolylineVolumeGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new bt(e);
    return i.entity.polylineVolume = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.polylineVolume = void 0);
  },
  cesiumProps: Sr,
  cesiumEventProps: Er
}), da = br, wr = ["enabled", "selected"], Dr = [
  "clearColor",
  "forcePowerOfTwo",
  "fragmentShader",
  "name",
  "pixelDatatype",
  "pixelFormat",
  "sampleMode",
  "scissorRectangle",
  "textureScale",
  "uniforms"
], ma = l({
  name: "PostProcessStage",
  create(i, e) {
    if (!i.scene)
      return;
    const t = new wt(e);
    return typeof e.enabled == "boolean" && (t.enabled = e.enabled), e.selected && (t.selected = e.selected), i.scene.postProcessStages.add(t), t;
  },
  destroy(i, e) {
    e.scene && !e.scene.isDestroyed() && e.scene.postProcessStages.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: wr,
  cesiumReadonlyProps: Dr
}), fa = U({
  name: "BlackAndWhiteStage",
  props: ["gradations"],
  create: () => Z.createBlackAndWhiteStage()
}), ha = U({
  name: "BrightnessStage",
  props: ["brightness"],
  create: () => Z.createBrightnessStage()
}), ya = U({
  name: "LensFlareStage",
  props: [
    "dirtTexture",
    "starTexture",
    "intensity",
    "distortion",
    "ghostDispersal",
    "haloWidth",
    "earthRadius"
  ],
  create: () => Z.createLensFlareStage()
}), pa = U({
  name: "Fxaa",
  create: (i, e) => e.fxaa,
  props: []
}), va = U({
  name: "NightVisionStage",
  props: [],
  create: () => Z.createNightVisionStage()
}), Rr = ["enabled", "selected"], $r = ["inputPreviousStageTexture", "name", "stages", "uniforms"], ga = l({
  name: "PostProcessStageComposite",
  create(i, e) {
    if (!i.scene)
      return;
    const t = new Dt(e);
    return typeof e.enabled == "boolean" && (t.enabled = e.enabled), e.selected && (t.selected = e.selected), i.scene.postProcessStages.add(t), t;
  },
  destroy(i, e) {
    e.scene && !e.scene.isDestroyed() && e.scene.postProcessStages.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: Rr,
  cesiumReadonlyProps: $r
}), Ca = U({
  name: "AmbientOcclusion",
  create: (i, e) => e.ambientOcclusion,
  props: [
    "ambientOcclusionOnly",
    "bias",
    "delta",
    "frustumLength",
    "intensity",
    "lengthCap",
    "sigma",
    "stepSize"
  ],
  noMount: !0
}), Pa = U({
  name: "Bloom",
  create: (i, e) => e.bloom,
  props: ["brightness", "contrast", "delta", "glowOnly", "sigma", "stepSize"],
  noMount: !0
}), Sa = U({
  name: "BlurStage",
  props: ["delta", "sigma", "stepSize"],
  create: () => Z.createBlurStage()
}), Ea = U({
  name: "DepthOfFieldStage",
  props: ["delta", "focalDistance", "sigma", "stepSize"],
  create: () => Z.createDepthOfFieldStage()
}), ba = U({
  name: "EdgeDetectionStage",
  props: ["color", "length"],
  create: () => Z.createEdgeDetectionStage()
}), wa = U({
  name: "SilhouetteStage",
  props: ["color", "length"],
  create: () => Z.createSilhouetteStage()
}), Tr = [
  "appearance",
  "cull",
  "debugShowBoundingVolume",
  "depthFailAppearance",
  "modelMatrix",
  "shadows",
  "show"
], Mr = [
  "allowPicking",
  "asynchronous",
  "compressVertices",
  "geometryInstances",
  "interleave",
  "releaseGeometryInstances",
  "vertexCacheOptimize"
], kr = ["onReady"], Lr = l({
  name: "Primitive",
  create(i, e) {
    var o;
    if (!i.primitiveCollection)
      return;
    const t = new Rt(e);
    if (e.onReady) {
      const r = () => {
        var c, u;
        t.ready && ((c = e.onReady) == null || c.call(e, t), (u = i.scene) == null || u.postRender.removeEventListener(r));
      };
      (o = i.scene) == null || o.postRender.addEventListener(r);
    }
    return i.primitiveCollection.add(t), t;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: Tr,
  cesiumReadonlyProps: Mr,
  otherProps: kr,
  useCommonEvent: !0
}), Da = Lr, _r = [
  "classificationType",
  "coordinates",
  "height",
  "heightReference",
  "extrudedHeight",
  "extrudedHeightReference",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "rotation",
  "stRotation",
  "granularity",
  "shadows",
  "distanceDisplayCondition",
  "zIndex"
], Or = {
  onDefinitionChange: "definitionChanged"
}, Gr = l({
  name: "RectangleGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new $t(e);
    return i.entity.rectangle = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.rectangle = void 0);
  },
  cesiumProps: _r,
  cesiumEventProps: Or
}), Ra = Gr, Br = [
  "backgroundColor",
  "completeMorphOnUserInput",
  "debugCommandFilter",
  "debugShowCommands",
  "debugShowDepthFrustum",
  "debugShowFramesPerSecond",
  "debugShowFrustumPlanes",
  "debugShowFrustums",
  "eyeSeparation",
  "farToNearRatio",
  "focalLength",
  "fog",
  "gamma",
  "globe",
  "highDynamicRange",
  "invertClassification",
  "invertClassificationColor",
  "light",
  "logarithmicDepthBuffer",
  "logarithmicDepthFarToNearRatio",
  "maximumRenderTimeChange",
  "minimumDisableDepthTestDistance",
  // "mode", // enable morph with animation
  "moon",
  "morphTime",
  "nearToFarDistance2D",
  "pickTranslucentDepth",
  "requestRenderMode",
  "rethrowRenderErrors",
  "shadowMap",
  "skyAtmosphere",
  "skyBox",
  "specularEnvironmentMaps",
  "sphericalHarmonicCoefficients",
  "sun",
  "sunBloom",
  "terrainProvider",
  "useDepthPicking",
  "useWebVR",
  "postProcessStages",
  "msaaSamples",
  "splitPosition",
  "debugCommandFilter",
  "verticalExaggeration",
  "verticalExaggerationRelativeHeight",
  "atmosphere"
], Ar = {
  onMorphComplete: "morphComplete",
  onMorphStart: "morphStart",
  onPostRender: "postRender",
  onPreRender: "preRender",
  onPreUpdate: "preUpdate",
  onPostUpdate: "postUpdate",
  onRenderError: "renderError",
  onTerrainProviderChange: "terrainProviderChanged"
}, Fr = ["mode", "morphDuration"], ui = (i, e, t) => {
  switch (e) {
    case Be.SCENE2D:
      i.morphTo2D(t);
      break;
    case Be.COLUMBUS_VIEW:
      i.morphToColumbusView(t);
      break;
    case Be.SCENE3D:
      i.morphTo3D(t);
      break;
  }
}, Ir = l({
  name: "Scene",
  create(i, e) {
    return i.scene && e.mode && ui(i.scene, e.mode, e.morphDuration), i.scene;
  },
  update(i, e, t) {
    e.mode !== t.mode && e.mode && ui(i, e.mode, e.morphDuration);
  },
  cesiumProps: Br,
  cesiumEventProps: Ar,
  otherProps: Fr,
  setCesiumPropsAfterCreate: !0
}), $a = Ir, Wr = [
  "bounceAnimationTime",
  "enableCollisionDetection",
  "enableInputs",
  "enableLook",
  "enableRotate",
  "enableTilt",
  "enableTranslate",
  "enableZoom",
  "inertiaSpin",
  "inertiaTranslate",
  "inertiaZoom",
  "lookEventTypes",
  "maximumMovementRatio",
  "maximumZoomDistance",
  "minimumCollisionTerrainHeight",
  "minimumPickingTerrainHeight",
  "minimumTrackBallHeight",
  "minimumZoomDistance",
  "rotateEventTypes",
  "tiltEventTypes",
  "translateEventTypes",
  "zoomEventTypes",
  "minimumPickingTerrainDistanceWithInertia"
], Vr = l({
  name: "ScreenSpaceCameraController",
  create: (i) => {
    var e;
    return (e = i.scene) == null ? void 0 : e.screenSpaceCameraController;
  },
  cesiumProps: Wr,
  setCesiumPropsAfterCreate: !0
}), Ta = Vr, Ur = ({ action: i, modifier: e, type: t }) => {
  const o = $e();
  return le(() => {
    if (!(!o.screenSpaceEventHandler || o.screenSpaceEventHandler.isDestroyed())) {
      if (i)
        return o.screenSpaceEventHandler.setInputAction(i, t, e), () => {
          !o.screenSpaceEventHandler || o.screenSpaceEventHandler.isDestroyed() || o.screenSpaceEventHandler.removeInputAction(t, e);
        };
      o.screenSpaceEventHandler.removeInputAction(t, e);
    }
  }, [i, o.screenSpaceEventHandler, e, t]), null;
}, Ma = Ur, jr = l({
  name: "ScreenSpaceEventHandler",
  create(i, e) {
    var t;
    return e.useDefault ? (t = i.cesiumWidget) == null ? void 0 : t.screenSpaceEventHandler : i.scene ? new hi(i.scene.canvas) : void 0;
  },
  destroy(i) {
    i.isDestroyed() || i.destroy();
  },
  provide(i) {
    return {
      screenSpaceEventHandler: i
    };
  }
}), ka = jr, Hr = [
  "darkness",
  "fadingEnabled",
  "maximumDistance",
  "enabled",
  "normalOffset",
  "softShadows",
  "size"
], zr = l({
  name: "ShadowMap",
  create: (i) => {
    var e;
    return (e = i.scene) == null ? void 0 : e.shadowMap;
  },
  cesiumProps: Hr
}), La = zr, xr = [
  "brightnessShift",
  "hueShift",
  "saturationShift",
  "show",
  "perFragmentAtmosphere",
  "atmosphereLightIntensity",
  "atmosphereRayleighCoefficient",
  "atmosphereMieCoefficient",
  "atmosphereRayleighScaleHeight",
  "atmosphereMieScaleHeight",
  "atmosphereMieAnisotropy"
], Nr = l({
  name: "SkyAtmosphere",
  create: (i) => {
    var e;
    return (e = i.scene) == null ? void 0 : e.skyAtmosphere;
  },
  cesiumProps: xr,
  setCesiumPropsAfterCreate: !0
}), _a = Nr, qr = ["sources", "show"], Yr = l({
  name: "SkyBox",
  create: (i) => {
    var e;
    return (e = i.scene) == null ? void 0 : e.skyBox;
  },
  cesiumProps: qr,
  setCesiumPropsAfterCreate: !0
}), Oa = Yr, Kr = ["glowFactor", "show"], Jr = l({
  name: "Sun",
  create(i) {
    if (!i.scene)
      return;
    const e = new ni();
    return i.scene.sun = e, e;
  },
  destroy(i, e) {
    e.scene && !e.scene.isDestroyed() && (e.scene.sun = new ni());
  },
  cesiumProps: Kr,
  setCesiumPropsAfterCreate: !0
}), Ga = Jr, Zr = [
  "clippingPlanes",
  "maximumMemoryUsage",
  "modelMatrix",
  "shadows",
  "show",
  "style",
  "intervals"
], Xr = ["clock", "shading"], Qr = ["onReady"], es = {
  onFrameChange: "frameChanged"
}, is = l({
  name: "TimeDynamicPointCloud",
  create(i, e) {
    var o;
    if (!i.cesiumWidget || !i.primitiveCollection || !((o = i.cesiumWidget) != null && o.clock))
      return;
    const t = new Tt({
      ...e,
      clock: e.clock ?? i.cesiumWidget.clock
    });
    if (e.onReady) {
      const r = () => {
        var c;
        (c = e.onReady) == null || c.call(e, t), t.frameChanged.removeEventListener(r);
      };
      t.frameChanged.addEventListener(r);
    }
    return i.primitiveCollection.add(t), t;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: Zr,
  cesiumReadonlyProps: Xr,
  cesiumEventProps: es,
  otherProps: Qr,
  useCommonEvent: !0
}), Ba = is, ts = [
  "terrainShadows",
  "clockTrackedDataSource",
  "targetFrameRate",
  "useDefaultRenderLoop",
  "resolutionScale",
  "allowDataSourcesToSuspendAnimation",
  "trackedEntity",
  "selectedEntity",
  "shadows",
  "useBrowserRecommendedResolution",
  "creditDisplay"
], ns = [
  "baseLayer",
  "animation",
  "baseLayerPicker",
  "fullscreenButton",
  "vrButton",
  "geocoder",
  "homeButton",
  "infoBox",
  "sceneModePicker",
  "selectionIndicator",
  "timeline",
  "navigationHelpButton",
  "navigationInstructionsInitiallyVisible",
  "scene3DOnly",
  "shouldAnimate",
  "clockViewModel",
  "selectedImageryProviderViewModel",
  "imageryProviderViewModels",
  "selectedTerrainProviderViewModel",
  "terrainProviderViewModels",
  "skyBox",
  "skyAtmosphere",
  "fullscreenElement",
  "showRenderLoopErrors",
  "automaticallyTrackDataSourceClocks",
  "contextOptions",
  "sceneMode",
  "mapProjection",
  "globe",
  "orderIndependentTranslucency",
  "creditContainer",
  "creditViewport",
  "dataSources",
  "mapMode2D",
  "projectionPicker",
  "requestRenderMode",
  "maximumRenderTimeChange",
  "depthPlaneEllipsoidOffset",
  "msaaSamples",
  "blurActiveElementOnCanvasFocus",
  "terrain"
], os = {
  onSelectedEntityChange: "selectedEntityChanged",
  onTrackedEntityChange: "trackedEntityChanged"
}, rs = [
  "className",
  "id",
  "style",
  "full",
  "containerProps",
  "extend",
  "terrainProvider"
], ss = l({
  name: "Viewer",
  async create(i, { baseLayer: e, terrainProvider: t, ...o }, r) {
    if (!r)
      return;
    let c;
    J(t) ? c = await t : c = t;
    const u = new Mt(r, {
      ...o,
      terrainProvider: c,
      baseLayer: e === !1 ? void 0 : e
    });
    if (!u)
      return;
    e === !1 && u.imageryLayers.removeAll(), u && o.extend && (Array.isArray(o.extend) ? o.extend.forEach((d) => {
      u.extend(d, {});
    }) : u.extend(o.extend, {}));
    const h = new De(u.scene);
    return [u, h];
  },
  destroy(i, e, t, o) {
    o && !o.isDestroyed() && o.destroy(), i.isDestroyed() || i.destroy();
  },
  provide(i, e, t, o) {
    return {
      viewer: i,
      cesiumWidget: i.cesiumWidget,
      dataSourceCollection: i.dataSources,
      entityCollection: i.entities,
      scene: i.scene,
      camera: i.scene.camera,
      imageryLayerCollection: i.scene.globe.imageryLayers,
      primitiveCollection: i.scene.primitives,
      globe: i.scene.globe,
      __$internal: {
        onUpdate: t == null ? void 0 : t.onUpdate,
        imageryLayerWaitingList: []
      },
      [ce]: o
    };
  },
  containerProps: ({ id: i, className: e, style: t, full: o, containerProps: r }) => ({
    className: e,
    id: i,
    style: {
      ...o ? {
        position: "absolute",
        bottom: "0",
        left: "0",
        right: "0",
        top: "0"
      } : {},
      ...t
    },
    ...r
  }),
  cesiumProps: ts,
  cesiumReadonlyProps: ns,
  cesiumEventProps: os,
  otherProps: rs,
  renderContainer: !0,
  useCommonEvent: !0,
  useRootEvent: !0
}), Aa = ss, as = [
  "positions",
  "maximumHeights",
  "minimumHeights",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "granularity",
  "shadows",
  "distanceDisplayCondition"
], cs = {
  onDefinitionChange: "definitionChanged"
}, ls = l({
  name: "WallGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const t = new kt(e);
    return i.entity.wall = t, t;
  },
  destroy(i, e) {
    e.entity && (e.entity.wall = void 0);
  },
  cesiumProps: as,
  cesiumEventProps: cs
}), Fa = ls;
export {
  Ca as AmbientOcclusion,
  ps as Billboard,
  vs as BillboardCollection,
  gs as BillboardGraphics,
  fa as BlackAndWhiteStage,
  Pa as Bloom,
  Sa as BlurStage,
  Cs as BoxGraphics,
  ha as BrightnessStage,
  Ps as Camera,
  Ss as CameraFlyHome,
  Es as CameraFlyTo,
  ws as CameraFlyToBoundingSphere,
  bs as CameraLookAt,
  Ds as Cesium3DTileset,
  Rs as Cesium3DTilesetGraphics,
  We as CesiumContext,
  $s as CesiumWidget,
  Ts as ClassificationPrimitive,
  Ms as Clock,
  ks as CloudCollection,
  _t as Consumer,
  Ls as CorridorGraphics,
  _s as CumulusCloud,
  Os as CustomDataSource,
  Gs as CylinderGraphics,
  Bs as CzmlDataSource,
  Ea as DepthOfFieldStage,
  ba as EdgeDetectionStage,
  As as EllipseGraphics,
  Fs as EllipsoidGraphics,
  Is as Entity,
  Ws as EntityDescription,
  De as EventManager,
  Vs as Fog,
  pa as Fxaa,
  Us as GeoJsonDataSource,
  js as Globe,
  Hs as GroundPolylinePrimitive,
  zs as GroundPrimitive,
  xs as GroundPrimitiveCollection,
  Ns as ImageryLayer,
  qs as ImageryLayerCollection,
  Ys as KmlDataSource,
  Ks as Label,
  Js as LabelCollection,
  Zs as LabelGraphics,
  ya as LensFlareStage,
  Xs as Model,
  Qs as ModelGraphics,
  ea as Moon,
  va as NightVisionStage,
  ia as ParticleSystem,
  ta as PathGraphics,
  na as PlaneGraphics,
  oa as PointGraphics,
  ra as PointPrimitive,
  sa as PointPrimitiveCollection,
  aa as PolygonGraphics,
  ca as Polyline,
  la as PolylineCollection,
  ua as PolylineGraphics,
  da as PolylineVolumeGraphics,
  ma as PostProcessStage,
  ga as PostProcessStageComposite,
  Da as Primitive,
  hs as Provider,
  Ra as RectangleGraphics,
  $a as Scene,
  Ta as ScreenSpaceCameraController,
  Ma as ScreenSpaceEvent,
  ka as ScreenSpaceEventHandler,
  La as ShadowMap,
  wa as SilhouetteStage,
  _a as SkyAtmosphere,
  Oa as SkyBox,
  Ga as Sun,
  Ba as TimeDynamicPointCloud,
  Aa as Viewer,
  Fa as WallGraphics,
  Te as createCameraOperation,
  l as createCesiumComponent,
  U as createPostProcessStage,
  Fe as entries,
  ce as eventManagerContextKey,
  Ie as eventNames,
  ve as includes,
  Ft as isDestroyable,
  It as isDestroyed,
  J as isPromise,
  Bt as pick,
  At as shallowEquals,
  $e as useCesium,
  Wt as useCesiumComponent,
  ys as withCesium
};
